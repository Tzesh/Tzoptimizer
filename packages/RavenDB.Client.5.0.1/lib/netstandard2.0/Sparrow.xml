<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Sparrow</name>
    </assembly>
    <members>
        <member name="M:Sparrow.Collections.FastList`1.WeakClear">
            <summary>
            This method is like Clear but will not release the references contained in it; therefore
            the garbage collector will not collect those objects even if they are not being used.
            </summary>
        </member>
        <member name="M:Sparrow.Collections.FastStack`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
            <internalonly/>
        </member>
        <member name="F:Sparrow.Compression.LZ4.LZ4_MEMORY_USAGE">
            <summary>
            LZ4_MEMORY_USAGE :
            Memory usage formula : N->2^N Bytes(examples : 10 -> 1KB; 12 -> 4KB ; 16 -> 64KB; 20 -> 1MB; etc.)
            Increasing memory usage improves compression ratio
            Reduced memory usage can improve speed, due to cache effect
            Default value is 14, for 16KB, which nicely fits into Intel x86 L1 cache
            </summary>
        </member>
        <member name="M:Sparrow.Compression.LZ4.MaximumOutputLength(System.Int64)">
            <summary>Gets maximum the length of the output.</summary>
            <param name="size">Length of the input.</param>
            <returns>Maximum number of bytes needed for compressed buffer.</returns>
        </member>
        <member name="T:Sparrow.Compression.SmallStringCompression">
            <summary>
            Based on https://github.com/antirez/smaz
            Full explanation is here:
            https://ayende.com/blog/172865/reverse-engineering-the-smaz-compression-library?key=cd1aaeff5ab64f1ebcf6e5556f9a7803
            </summary>
        </member>
        <member name="F:Sparrow.DefaultFormat.DateTimeFormatsToRead">
            <remarks>
            'r' format is used on the in metadata, because it's delivered as http header. 
            </remarks>
        </member>
        <member name="M:Sparrow.Extensions.RavenDateTimeExtensions.GetDefaultRavenFormat(System.DateTime,System.Boolean)">
            <summary>
            This function Processes the to string format of the form "yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffff" for date times in 
            invariant culture scenarios. This implementation takes 20% of the time of a regular .ToString(format) call
            </summary>
            <param name="dt"></param>
            <param name="isUtc"></param>
            <returns></returns>
        </member>
        <member name="M:Sparrow.Extensions.RavenDateTimeExtensions.GetDefaultRavenFormat(System.DateTime,Sparrow.Json.JsonOperationContext,Sparrow.Json.AllocatedMemoryData@,System.Boolean)">
            <summary>
            This function Processes the to string format of the form "yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffff" for date times in 
            invariant culture scenarios. This implementation takes 20% of the time of a regular .ToString(format) call
            </summary>
            <param name="dt"></param>
            <param name="isUtc"></param>
            <returns></returns>
        </member>
        <member name="M:Sparrow.Extensions.RavenDateTimeExtensions.GetDefaultRavenFormat(System.DateTime,Sparrow.Json.AllocatedMemoryData,System.Boolean)">
            <summary>
            This function Processes the to string format of the form "yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffff" for date times in 
            invariant culture scenarios. This implementation takes 20% of the time of a regular .ToString(format) call
            </summary>
            <param name="dt"></param>
            <param name="isUtc"></param>
            <returns></returns>
        </member>
        <member name="T:Sparrow.Hashing.XXHash32">
            <summary>
            A port of the original XXHash algorithm from Google in 32bits 
            </summary>
            <remarks>The 32bits and 64bits hashes for the same data are different. In short those are 2 entirely different algorithms</remarks>
        </member>
        <member name="T:Sparrow.Hashing.XXHash64">
            <summary>
            A port of the original XXHash algorithm from Google in 64bits 
            </summary>
            <remarks>The 32bits and 64bits hashes for the same data are different. In short those are 2 entirely different algorithms</remarks>
        </member>
        <member name="M:Sparrow.Hashing.HashCombiner.Combine(System.Int32,System.Int32)">
            <summary>
            The combine function will perform the mixing of 2 hash values into a single one.
            It is important that the parameters are hash functions. If they are not the statistical properties of the output will be quite bad.
            For non hashes use <see cref="M:Sparrow.Hashing.Combine(System.UInt64,System.UInt64)"/> instead
            </summary>
            <param name="x">The first hash value</param>
            <param name="y">The second hash value</param>
            <returns>The combined hash value</returns>
        </member>
        <member name="M:Sparrow.Hashing.HashCombiner.Combine(System.UInt32,System.UInt32)">
            <summary>
            The combine function will perform the mixing of 2 hash values into a single one.
            It is important that the parameters are hash functions. If they are not the statistical properties of the output will be quite bad.
            For non hashes use <see cref="M:Sparrow.Hashing.Combine(System.UInt64,System.UInt64)"/> instead
            </summary>
            <param name="x">The first hash value</param>
            <param name="y">The second hash value</param>
            <returns>The combined hash value</returns>
        </member>
        <member name="M:Sparrow.Hashing.HashCombiner.Combine(System.Int64,System.Int64)">
            <summary>
            The combine function will perform the mixing of 2 hash values into a single one.
            It is important that the parameters are hash functions. If they are not the statistical properties of the output will be quite bad.
            For non hashes use <see cref="M:Sparrow.Hashing.Combine(System.UInt64,System.UInt64)"/> instead
            </summary>
            <param name="x">The first hash value</param>
            <param name="y">The second hash value</param>
            <returns>The combined hash value</returns>
        </member>
        <member name="M:Sparrow.Hashing.HashCombiner.Combine(System.UInt64,System.UInt64)">
            <summary>
            The combine function will perform the mixing of 2 hash values into a single one.
            It is important that the parameters are hash functions. If they are not the statistical properties of the output will be quite bad.
            For non hashes use <see cref="M:Sparrow.Hashing.Combine(System.UInt64,System.UInt64)"/> instead
            </summary>
            <param name="x">The first hash value</param>
            <param name="y">The second hash value</param>
            <returns>The combined hash value</returns>
        </member>
        <member name="M:Sparrow.Hashing.HashCombiner.CombineInline(System.Int32,System.Int32)">
            <summary>
            The combine function will perform the mixing of 2 hash values into a single one.
            It is important that the parameters are hash functions. If they are not the statistical properties of the output will be quite bad.
            For non hashes use <see cref="M:Sparrow.Hashing.Combine(System.UInt64,System.UInt64)"/> instead
            </summary>
            <remarks>This version will force inlining on the call-site</remarks>
            <param name="x">The first hash value</param>
            <param name="y">The second hash value</param>
            <returns>The combined hash value</returns>
        </member>
        <member name="M:Sparrow.Hashing.HashCombiner.CombineInline(System.UInt32,System.UInt32)">
            <summary>
            The combine function will perform the mixing of 2 hash values into a single one.
            It is important that the parameters are hash functions. If they are not the statistical properties of the output will be quite bad.
            For non hashes use <see cref="M:Sparrow.Hashing.Combine(System.UInt64,System.UInt64)"/> instead
            </summary>
            <remarks>This version will force inlining on the call-site</remarks>
            <param name="x">The first hash value</param>
            <param name="y">The second hash value</param>
            <returns>The combined hash value</returns>
        </member>
        <member name="M:Sparrow.Hashing.HashCombiner.CombineInline(System.Int64,System.Int64)">
            <summary>
            The combine function will perform the mixing of 2 hash values into a single one.
            It is important that the parameters are hash functions. If they are not the statistical properties of the output will be quite bad.
            For non hashes use <see cref="M:Sparrow.Hashing.Combine(System.UInt64,System.UInt64)"/> instead
            </summary>
            <remarks>This version will force inlining on the call-site</remarks>
            <param name="x">The first hash value</param>
            <param name="y">The second hash value</param>
            <returns>The combined hash value</returns>
        </member>
        <member name="M:Sparrow.Hashing.HashCombiner.CombineInline(System.UInt64,System.UInt64)">
            <summary>
            The combine function will perform the mixing of 2 hash values into a single one.
            It is important that the parameters are hash functions. If they are not the statistical properties of the output will be quite bad.
            For non hashes use <see cref="M:Sparrow.Hashing.Combine(System.UInt64,System.UInt64)"/> instead
            </summary>
            <remarks>This version will force inlining on the call-site</remarks>
            <param name="x">The first hash value</param>
            <param name="y">The second hash value</param>
            <returns>The combined hash value</returns>
        </member>
        <member name="M:Sparrow.Json.BlittableJsonReaderObject.GetPropertyNames">
            <summary>
            Returns an array of property names, ordered in the order it was stored 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sparrow.Json.BlittableJsonReaderObject.ComparePropertyName(System.Int32,Sparrow.Json.LazyStringValue)">
            <summary>
            Compares property names between received StringToByteComparer and the string stored in the document's property names storage
            </summary>
            <param name="propertyId">Position of the string in the property ids storage</param>
            <param name="comparer">Comparer of a specific string value</param>
            <param name="ignoreCase">Indicates if the comparassion should be case insensitive</param>
            <returns></returns>
        </member>
        <member name="T:Sparrow.Json.CachedProperties">
            <summary>
            This class allows us to cache the properties from multiple documents
            That way, we don't need to recompute the sort order.
            
            However, because different documents may have different fields, we're tracking
            which properties we have seen and which are new. If the order in which we read the 
            properties doesn't match the cached version, we'll clear the cache up to the point the
            properties match. 
            
            This is done so we'll not write properties that don't belong to that document, but to 
            previous documents handled in the same batch
            </summary>
        </member>
        <member name="T:Sparrow.Json.JsonDeserializationIgnoreAttribute">
            <summary>
            Instructs the <see cref="T:Sparrow.Json.JsonDeserializationBase"/> not to serialize the public field or public read/write property value.
            </summary>
        </member>
        <member name="T:Sparrow.Json.JsonOperationContext">
            <summary>
            Single threaded for contexts
            </summary>
        </member>
        <member name="F:Sparrow.Json.JsonOperationContext.DoNotReuse">
            <summary>
            This flag means that this should be disposed, usually because we exceeded the maximum
            amount of memory budget we have and need to return it to the system
            </summary>
        </member>
        <member name="M:Sparrow.Json.JsonOperationContext.GetStream(System.Int32)">
            <summary>
            Generates new unmanaged stream. Should be disposed at the end of the usage.
            </summary>
        </member>
        <member name="M:Sparrow.Json.LazyCompressedStringValue.ToLazyStringValue">
            <summary>
            Returns uncompressed data in form of LazyStringValue
            </summary>
            <returns></returns>
        </member>
        <member name="T:Sparrow.Json.LazyStringParser">
            <summary>
            This class assumes that the data is in UTF8
            </summary>
        </member>
        <member name="M:Sparrow.Json.ManualBlittableJsonDocumentBuilder`1.#ctor(Sparrow.Json.JsonOperationContext,System.Nullable{Sparrow.Json.BlittableJsonDocumentBuilder.UsageMode},Sparrow.Json.BlittableWriter{`0})">
            <summary>
            Allows incrementally building json document
            </summary>
            <param name="context"></param>
            <param name="mode"></param>
            <param name="writer"></param>
        </member>
        <member name="F:Sparrow.Json.UnmanagedWriteBuffer.Segment.Previous">
            <summary>
            This points to the previous Segment in the stream. May be null
            due either to a Clean operation, or because none have been
            allocated
            </summary>
        </member>
        <member name="F:Sparrow.Json.UnmanagedWriteBuffer.Segment.DeallocationPendingPrevious">
            <summary>
            Every Segment in this linked list is freed when the 
            UnmanagedWriteBuffer is disposed. Kept for resilience against
            Clean operations
            </summary>
        </member>
        <member name="F:Sparrow.Json.UnmanagedWriteBuffer.Segment.Allocation">
            <summary>
            Memory in this Segment
            </summary>
        </member>
        <member name="F:Sparrow.Json.UnmanagedWriteBuffer.Segment.Address">
            <summary>
            Always set to Allocation.Adddress
            </summary>
        </member>
        <member name="F:Sparrow.Json.UnmanagedWriteBuffer.Segment.Used">
            <summary>
            Used bytes in the current Segment
            </summary>
        </member>
        <member name="F:Sparrow.Json.UnmanagedWriteBuffer.Segment.AccumulatedSizeInBytes">
            <summary>
            Total size accumulated by all the previous Segments
            </summary>
        </member>
        <member name="T:Sparrow.ObjectPool`1">
            <summary>
            Generic implementation of object pooling pattern with predefined pool size limit. The main
            purpose is that limited number of frequently used objects can be kept in the pool for
            further recycling.
            
            Notes: 
            1) it is not the goal to keep all returned objects. Pool is not meant for storage. If there
               is no space in the pool, extra returned objects will be dropped.
            
            2) it is implied that if object was obtained from a pool, the caller will return it back in
               a relatively short time. Keeping checked out objects for long durations is ok, but 
               reduces usefulness of pooling. Just new up your own.
            
            Not returning objects to the pool in not detrimental to the pool's work, but is a bad practice. 
            Rationale: 
               If there is no intent for reusing the object, do not use pool - just use "new". 
            </summary>
        </member>
        <member name="T:Sparrow.ObjectPool`2">
            <summary>
            Generic implementation of object pooling pattern with predefined pool size limit. The main
            purpose is that limited number of frequently used objects can be kept in the pool for
            further recycling.
            
            Notes: 
            1) it is not the goal to keep all returned objects. Pool is not meant for storage. If there
               is no space in the pool, extra returned objects will be dropped.
            
            2) it is implied that if object was obtained from a pool, the caller will return it back in
               a relatively short time. Keeping checked out objects for long durations is ok, but 
               reduces usefulness of pooling. Just new up your own.
            
            Not returning objects to the pool in not detrimental to the pool's work, but is a bad practice. 
            Rationale: 
               If there is no intent for reusing the object, do not use pool - just use "new". 
            </summary>
        </member>
        <member name="T:Sparrow.ObjectPool`2.Factory">
            <remarks>
            Not using System.Func{T} because this file is linked into the (debugger) Formatter,
            which does not have that type (since it compiles against .NET 2.0).
            </remarks>
        </member>
        <member name="M:Sparrow.ObjectPool`2.Allocate">
            <summary>
            Produces an instance.
            </summary>
            <remarks>
            Search strategy is a simple linear probing which is chosen for it cache-friendliness.
            Note that Free will try to store recycled objects close to the start thus statistically 
            reducing how far we will typically search.
            </remarks>
        </member>
        <member name="M:Sparrow.ObjectPool`2.Free(`0)">
            <summary>
            Returns objects to the pool.
            </summary>
            <remarks>
            Search strategy is a simple linear probing which is chosen for it cache-friendliness.
            Note that Free will try to store recycled objects close to the start thus statistically 
            reducing how far we will typically search in Allocate.
            </remarks>
        </member>
        <member name="M:Sparrow.ObjectPool`2.ForgetTrackedObject(`0,`0)">
            <summary>
            Removes an object from leak tracking.  
            
            This is called when an object is returned to the pool.  It may also be explicitly 
            called if an object allocated from the pool is intentionally not being returned
            to the pool.  This can be of use with pooled arrays if the consumer wants to 
            return a larger array to the pool than was originally allocated.
            </summary>
        </member>
        <member name="M:Sparrow.PeepingTomStream.#ctor(System.IO.Stream,Sparrow.Json.JsonOperationContext.MemoryBuffer)">
            <summary>
            FOR TESTING PURPOSES ONLY
            </summary>
        </member>
        <member name="T:Sparrow.OrdinalStringStructComparer">
            <summary>
            The struct compared is optimized for small strings that come from the outside of the controlled fence, 
            the hash function used is compact (making it suitable for inlining) and also flood resistant. 
            </summary>
        </member>
        <member name="T:Sparrow.OrdinalIgnoreCaseStringStructComparer">
            <summary>
            The struct compared is optimized for small strings that come from the outside of the controlled fence, 
            the hash function used is compact (making it suitable for inlining) and also flood resistant. 
            </summary>
        </member>
        <member name="T:Sparrow.StringSegment">
            <summary>
            An optimized representation of a substring.
            </summary>
        </member>
        <member name="F:Sparrow.StringSegment.Empty">
            <summary>
            A <see cref="T:Sparrow.StringSegment"/> for <see cref="F:System.String.Empty"/>.
            </summary>
        </member>
        <member name="M:Sparrow.StringSegment.#ctor(System.String)">
            <summary>
            Initializes an instance of the <see cref="T:Sparrow.StringSegment"/> struct.
            </summary>
            <param name="buffer">
            The original <see cref="T:System.String"/>. The <see cref="T:Sparrow.StringSegment"/> includes the whole <see cref="T:System.String"/>.
            </param>
        </member>
        <member name="M:Sparrow.StringSegment.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
            Initializes an instance of the <see cref="T:Sparrow.StringSegment"/> struct.
            </summary>
            <param name="buffer">The original <see cref="T:System.String"/> used as buffer.</param>
            <param name="offset">The offset of the segment within the <paramref name="buffer"/>.</param>
            <param name="length">The length of the segment.</param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="buffer"/> is <code>null</code>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="offset"/> or <paramref name="length"/> is less than zero, or <paramref name="offset"/> +
            <paramref name="length"/> is greater than the number of characters in <paramref name="buffer"/>.
            </exception>
        </member>
        <member name="P:Sparrow.StringSegment.Buffer">
            <summary>
            Gets the <see cref="T:System.String"/> buffer for this <see cref="T:Sparrow.StringSegment"/>.
            </summary>
        </member>
        <member name="P:Sparrow.StringSegment.Offset">
            <summary>
            Gets the offset within the buffer for this <see cref="T:Sparrow.StringSegment"/>.
            </summary>
        </member>
        <member name="P:Sparrow.StringSegment.Length">
            <summary>
            Gets the length of this <see cref="T:Sparrow.StringSegment"/>.
            </summary>
        </member>
        <member name="P:Sparrow.StringSegment.Value">
            <summary>
            Gets the value of this segment as a <see cref="T:System.String"/>.
            </summary>
        </member>
        <member name="P:Sparrow.StringSegment.HasValue">
            <summary>
            Gets whether this <see cref="T:Sparrow.StringSegment"/> contains a valid value.
            </summary>
        </member>
        <member name="P:Sparrow.StringSegment.Item(System.Int32)">
            <summary>
            Gets the <see cref="T:System.Char"/> at a specified position in the current <see cref="T:Sparrow.StringSegment"/>.
            </summary>
            <param name="index">The offset into the <see cref="T:Sparrow.StringSegment"/></param>
            <returns>The <see cref="T:System.Char"/> at a specified position.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="index"/> is greater than or equal to <see cref="P:Sparrow.StringSegment.Length"/> or less than zero.
            </exception>
        </member>
        <member name="M:Sparrow.StringSegment.AsSpan">
            <summary>
            Gets a <see cref="T:System.ReadOnlySpan`1"/> from the current <see cref="T:Sparrow.StringSegment"/>.
            </summary>
            <returns>The <see cref="T:System.ReadOnlySpan`1"/> from this <see cref="T:Sparrow.StringSegment"/>.</returns>
        </member>
        <member name="M:Sparrow.StringSegment.AsMemory">
            <summary>
            Gets a <see cref="T:System.ReadOnlyMemory`1"/> from the current <see cref="T:Sparrow.StringSegment"/>.
            </summary>
            <returns>The <see cref="T:System.ReadOnlyMemory`1"/> from this <see cref="T:Sparrow.StringSegment"/>.</returns>
        </member>
        <member name="M:Sparrow.StringSegment.Compare(Sparrow.StringSegment,Sparrow.StringSegment,System.StringComparison)">
            <summary>
            Compares substrings of two specified <see cref="T:Sparrow.StringSegment"/> objects using the specified rules,
            and returns an integer that indicates their relative position in the sort order.
            </summary>
            <param name="a">The first <see cref="T:Sparrow.StringSegment"/> to compare.</param>
            <param name="b">The second <see cref="T:Sparrow.StringSegment"/> to compare.</param>
            <param name="comparisonType">One of the enumeration values that specifies the rules for the comparison.</param>
            <returns>
            A 32-bit signed integer indicating the lexical relationship between the two comparands.
            The value is negative if <paramref name="a"/> is less than <paramref name="b"/>, 0 if the two comparands are equal,
            and positive if <paramref name="a"/> is greater than <paramref name="b"/>.
            </returns>
        </member>
        <member name="M:Sparrow.StringSegment.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Sparrow.StringSegment.Equals(Sparrow.StringSegment)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns><code>true</code> if the current object is equal to the other parameter; otherwise, <code>false</code>.</returns>
        </member>
        <member name="M:Sparrow.StringSegment.Equals(Sparrow.StringSegment,System.StringComparison)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <param name="comparisonType">One of the enumeration values that specifies the rules to use in the comparison.</param>
            <returns><code>true</code> if the current object is equal to the other parameter; otherwise, <code>false</code>.</returns>
        </member>
        <member name="M:Sparrow.StringSegment.Equals(Sparrow.StringSegment,Sparrow.StringSegment,System.StringComparison)">
            <summary>
            Determines whether two specified <see cref="T:Sparrow.StringSegment"/> objects have the same value. A parameter specifies the culture, case, and
            sort rules used in the comparison.
            </summary>
            <param name="a">The first <see cref="T:Sparrow.StringSegment"/> to compare.</param>
            <param name="b">The second <see cref="T:Sparrow.StringSegment"/> to compare.</param>
            <param name="comparisonType">One of the enumeration values that specifies the rules for the comparison.</param>
            <returns><code>true</code> if the objects are equal; otherwise, <code>false</code>.</returns>
        </member>
        <member name="M:Sparrow.StringSegment.Equals(System.String)">
            <summary>
            Checks if the specified <see cref="T:System.String"/> is equal to the current <see cref="T:Sparrow.StringSegment"/>.
            </summary>
            <param name="text">The <see cref="T:System.String"/> to compare with the current <see cref="T:Sparrow.StringSegment"/>.</param>
            <returns><code>true</code> if the specified <see cref="T:System.String"/> is equal to the current <see cref="T:Sparrow.StringSegment"/>; otherwise, <code>false</code>.</returns>
        </member>
        <member name="M:Sparrow.StringSegment.Equals(System.String,System.StringComparison)">
            <summary>
            Checks if the specified <see cref="T:System.String"/> is equal to the current <see cref="T:Sparrow.StringSegment"/>.
            </summary>
            <param name="text">The <see cref="T:System.String"/> to compare with the current <see cref="T:Sparrow.StringSegment"/>.</param>
            <param name="comparisonType">One of the enumeration values that specifies the rules to use in the comparison.</param>
            <returns><code>true</code> if the specified <see cref="T:System.String"/> is equal to the current <see cref="T:Sparrow.StringSegment"/>; otherwise, <code>false</code>.</returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="text"/> is <code>null</code>.
            </exception>
        </member>
        <member name="M:Sparrow.StringSegment.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Sparrow.StringSegment.op_Equality(Sparrow.StringSegment,Sparrow.StringSegment)">
            <summary>
            Checks if two specified <see cref="T:Sparrow.StringSegment"/> have the same value.
            </summary>
            <param name="left">The first <see cref="T:Sparrow.StringSegment"/> to compare, or <code>null</code>.</param>
            <param name="right">The second <see cref="T:Sparrow.StringSegment"/> to compare, or <code>null</code>.</param>
            <returns><code>true</code> if the value of <paramref name="left"/> is the same as the value of <paramref name="right"/>; otherwise, <code>false</code>.</returns>
        </member>
        <member name="M:Sparrow.StringSegment.op_Inequality(Sparrow.StringSegment,Sparrow.StringSegment)">
            <summary>
            Checks if two specified <see cref="T:Sparrow.StringSegment"/> have different values.
            </summary>
            <param name="left">The first <see cref="T:Sparrow.StringSegment"/> to compare, or <code>null</code>.</param>
            <param name="right">The second <see cref="T:Sparrow.StringSegment"/> to compare, or <code>null</code>.</param>
            <returns><code>true</code> if the value of <paramref name="left"/> is different from the value of <paramref name="right"/>; otherwise, <code>false</code>.</returns>
        </member>
        <member name="M:Sparrow.StringSegment.op_Implicit(System.String)~Sparrow.StringSegment">
            <summary>
            Creates a new <see cref="T:Sparrow.StringSegment"/> from the given <see cref="T:System.String"/>.
            </summary>
            <param name="value">The <see cref="T:System.String"/> to convert to a <see cref="T:Sparrow.StringSegment"/></param>
        </member>
        <member name="M:Sparrow.StringSegment.op_Implicit(Sparrow.StringSegment)~System.ReadOnlySpan{System.Char}">
            <summary>
            Creates a see <see cref="T:System.ReadOnlySpan`1"/> from the given <see cref="T:Sparrow.StringSegment"/>.
            </summary>
            <param name="segment">The <see cref="T:Sparrow.StringSegment"/> to convert to a <see cref="T:System.ReadOnlySpan`1"/>.</param>
        </member>
        <member name="M:Sparrow.StringSegment.op_Implicit(Sparrow.StringSegment)~System.ReadOnlyMemory{System.Char}">
            <summary>
            Creates a see <see cref="T:System.ReadOnlyMemory`1"/> from the given <see cref="T:Sparrow.StringSegment"/>.
            </summary>
            <param name="segment">The <see cref="T:Sparrow.StringSegment"/> to convert to a <see cref="T:System.ReadOnlyMemory`1"/>.</param>
        </member>
        <member name="M:Sparrow.StringSegment.StartsWith(System.String,System.StringComparison)">
            <summary>
            Checks if the beginning of this <see cref="T:Sparrow.StringSegment"/> matches the specified <see cref="T:System.String"/> when compared using the specified <paramref name="comparisonType"/>.
            </summary>
            <param name="text">The <see cref="T:System.String"/>to compare.</param>
            <param name="comparisonType">One of the enumeration values that specifies the rules to use in the comparison.</param>
            <returns><code>true</code> if <paramref name="text"/> matches the beginning of this <see cref="T:Sparrow.StringSegment"/>; otherwise, <code>false</code>.</returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="text"/> is <code>null</code>.
            </exception>
        </member>
        <member name="M:Sparrow.StringSegment.EndsWith(System.String,System.StringComparison)">
            <summary>
            Checks if the end of this <see cref="T:Sparrow.StringSegment"/> matches the specified <see cref="T:System.String"/> when compared using the specified <paramref name="comparisonType"/>.
            </summary>
            <param name="text">The <see cref="T:System.String"/>to compare.</param>
            <param name="comparisonType">One of the enumeration values that specifies the rules to use in the comparison.</param>
            <returns><code>true</code> if <paramref name="text"/> matches the end of this <see cref="T:Sparrow.StringSegment"/>; otherwise, <code>false</code>.</returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="text"/> is <code>null</code>.
            </exception>
        </member>
        <member name="M:Sparrow.StringSegment.Substring(System.Int32)">
            <summary>
            Retrieves a substring from this <see cref="T:Sparrow.StringSegment"/>.
            The substring starts at the position specified by <paramref name="offset"/> and has the remaining length.
            </summary>
            <param name="offset">The zero-based starting character position of a substring in this <see cref="T:Sparrow.StringSegment"/>.</param>
            <returns>A <see cref="T:System.String"/> that is equivalent to the substring of remaining length that begins at
            <paramref name="offset"/> in this <see cref="T:Sparrow.StringSegment"/></returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="offset"/> is greater than or equal to <see cref="P:Sparrow.StringSegment.Length"/> or less than zero.
            </exception>
        </member>
        <member name="M:Sparrow.StringSegment.Substring(System.Int32,System.Int32)">
            <summary>
            Retrieves a substring from this <see cref="T:Sparrow.StringSegment"/>.
            The substring starts at the position specified by <paramref name="offset"/> and has the specified <paramref name="length"/>.
            </summary>
            <param name="offset">The zero-based starting character position of a substring in this <see cref="T:Sparrow.StringSegment"/>.</param>
            <param name="length">The number of characters in the substring.</param>
            <returns>A <see cref="T:System.String"/> that is equivalent to the substring of length <paramref name="length"/> that begins at
            <paramref name="offset"/> in this <see cref="T:Sparrow.StringSegment"/></returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="offset"/> or <paramref name="length"/> is less than zero, or <paramref name="offset"/> + <paramref name="length"/> is
            greater than <see cref="P:Sparrow.StringSegment.Length"/>.
            </exception>
        </member>
        <member name="M:Sparrow.StringSegment.Subsegment(System.Int32)">
            <summary>
            Retrieves a <see cref="T:Sparrow.StringSegment"/> that represents a substring from this <see cref="T:Sparrow.StringSegment"/>.
            The <see cref="T:Sparrow.StringSegment"/> starts at the position specified by <paramref name="offset"/>.
            </summary>
            <param name="offset">The zero-based starting character position of a substring in this <see cref="T:Sparrow.StringSegment"/>.</param>
            <returns>A <see cref="T:Sparrow.StringSegment"/> that begins at <paramref name="offset"/> in this <see cref="T:Sparrow.StringSegment"/>
            whose length is the remainder.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="offset"/> is greater than or equal to <see cref="P:Sparrow.StringSegment.Length"/> or less than zero.
            </exception>
        </member>
        <member name="M:Sparrow.StringSegment.Subsegment(System.Int32,System.Int32)">
            <summary>
            Retrieves a <see cref="T:Sparrow.StringSegment"/> that represents a substring from this <see cref="T:Sparrow.StringSegment"/>.
            The <see cref="T:Sparrow.StringSegment"/> starts at the position specified by <paramref name="offset"/> and has the specified <paramref name="length"/>.
            </summary>
            <param name="offset">The zero-based starting character position of a substring in this <see cref="T:Sparrow.StringSegment"/>.</param>
            <param name="length">The number of characters in the substring.</param>
            <returns>A <see cref="T:Sparrow.StringSegment"/> that is equivalent to the substring of length <paramref name="length"/> that begins at <paramref name="offset"/> in this <see cref="T:Sparrow.StringSegment"/></returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="offset"/> or <paramref name="length"/> is less than zero, or <paramref name="offset"/> + <paramref name="length"/> is
            greater than <see cref="P:Sparrow.StringSegment.Length"/>.
            </exception>
        </member>
        <member name="M:Sparrow.StringSegment.IndexOf(System.Char,System.Int32,System.Int32)">
            <summary>
            Gets the zero-based index of the first occurrence of the character <paramref name="c"/> in this <see cref="T:Sparrow.StringSegment"/>.
            The search starts at <paramref name="start"/> and examines a specified number of <paramref name="count"/> character positions.
            </summary>
            <param name="c">The Unicode character to seek.</param>
            <param name="start">The zero-based index position at which the search starts. </param>
            <param name="count">The number of characters to examine.</param>
            <returns>The zero-based index position of <paramref name="c"/> from the beginning of the <see cref="T:Sparrow.StringSegment"/> if that character is found, or -1 if it is not.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="start"/> or <paramref name="count"/> is less than zero, or <paramref name="start"/> + <paramref name="count"/> is
            greater than <see cref="P:Sparrow.StringSegment.Length"/>.
            </exception>
        </member>
        <member name="M:Sparrow.StringSegment.IndexOf(System.Char,System.Int32)">
            <summary>
            Gets the zero-based index of the first occurrence of the character <paramref name="c"/> in this <see cref="T:Sparrow.StringSegment"/>.
            The search starts at <paramref name="start"/>.
            </summary>
            <param name="c">The Unicode character to seek.</param>
            <param name="start">The zero-based index position at which the search starts. </param>
            <returns>The zero-based index position of <paramref name="c"/> from the beginning of the <see cref="T:Sparrow.StringSegment"/> if that character is found, or -1 if it is not.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="start"/> is greater than or equal to <see cref="P:Sparrow.StringSegment.Length"/> or less than zero.
            </exception>
        </member>
        <member name="M:Sparrow.StringSegment.IndexOf(System.Char)">
            <summary>
            Gets the zero-based index of the first occurrence of the character <paramref name="c"/> in this <see cref="T:Sparrow.StringSegment"/>.
            </summary>
            <param name="c">The Unicode character to seek.</param>
            <returns>The zero-based index position of <paramref name="c"/> from the beginning of the <see cref="T:Sparrow.StringSegment"/> if that character is found, or -1 if it is not.</returns>
        </member>
        <member name="M:Sparrow.StringSegment.IndexOfAny(System.Char[],System.Int32,System.Int32)">
            <summary>
            Reports the zero-based index of the first occurrence in this instance of any character in a specified array
            of Unicode characters. The search starts at a specified character position and examines a specified number
            of character positions.
            </summary>
            <param name="anyOf">A Unicode character array containing one or more characters to seek.</param>
            <param name="startIndex">The search starting position.</param>
            <param name="count">The number of character positions to examine.</param>
            <returns>The zero-based index position of the first occurrence in this instance where any character in <paramref name="anyOf"/>
            was found; -1 if no character in <paramref name="anyOf"/> was found.</returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="anyOf"/> is <code>null</code>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="startIndex"/> or <paramref name="count"/> is less than zero, or <paramref name="startIndex"/> + <paramref name="count"/> is
            greater than <see cref="P:Sparrow.StringSegment.Length"/>.
            </exception>
        </member>
        <member name="M:Sparrow.StringSegment.IndexOfAny(System.Char[],System.Int32)">
            <summary>
            Reports the zero-based index of the first occurrence in this instance of any character in a specified array
            of Unicode characters. The search starts at a specified character position.
            </summary>
            <param name="anyOf">A Unicode character array containing one or more characters to seek.</param>
            <param name="startIndex">The search starting position.</param>
            <returns>The zero-based index position of the first occurrence in this instance where any character in <paramref name="anyOf"/>
            was found; -1 if no character in <paramref name="anyOf"/> was found.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="startIndex"/> is greater than or equal to <see cref="P:Sparrow.StringSegment.Length"/> or less than zero.
            </exception>
        </member>
        <member name="M:Sparrow.StringSegment.IndexOfAny(System.Char[])">
            <summary>
            Reports the zero-based index of the first occurrence in this instance of any character in a specified array
            of Unicode characters.
            </summary>
            <param name="anyOf">A Unicode character array containing one or more characters to seek.</param>
            <returns>The zero-based index position of the first occurrence in this instance where any character in <paramref name="anyOf"/>
            was found; -1 if no character in <paramref name="anyOf"/> was found.</returns>
        </member>
        <member name="M:Sparrow.StringSegment.LastIndexOf(System.Char)">
            <summary>
            Reports the zero-based index position of the last occurrence of a specified Unicode character within this instance.
            </summary>
            <param name="value">The Unicode character to seek.</param>
            <returns>The zero-based index position of value if that character is found, or -1 if it is not.</returns>
        </member>
        <member name="M:Sparrow.StringSegment.Trim">
            <summary>
            Removes all leading and trailing whitespaces.
            </summary>
            <returns>The trimmed <see cref="T:Sparrow.StringSegment"/>.</returns>
        </member>
        <member name="M:Sparrow.StringSegment.TrimStart">
            <summary>
            Removes all leading whitespaces.
            </summary>
            <returns>The trimmed <see cref="T:Sparrow.StringSegment"/>.</returns>
        </member>
        <member name="M:Sparrow.StringSegment.TrimEnd">
            <summary>
            Removes all trailing whitespaces.
            </summary>
            <returns>The trimmed <see cref="T:Sparrow.StringSegment"/>.</returns>
        </member>
        <member name="M:Sparrow.StringSegment.IsNullOrEmpty(Sparrow.StringSegment)">
            <summary>
            Indicates whether the specified <see cref="T:Sparrow.StringSegment"/> is null or an Empty string.
            </summary>
            <param name="value">The <see cref="T:Sparrow.StringSegment"/> to test.</param>
            <returns></returns>
        </member>
        <member name="M:Sparrow.StringSegment.ToString">
            <summary>
            Returns the <see cref="T:System.String"/> represented by this <see cref="T:Sparrow.StringSegment"/> or <code>String.Empty</code> if the <see cref="T:Sparrow.StringSegment"/> does not contain a value.
            </summary>
            <returns>The <see cref="T:System.String"/> represented by this <see cref="T:Sparrow.StringSegment"/> or <code>String.Empty</code> if the <see cref="T:Sparrow.StringSegment"/> does not contain a value.</returns>
        </member>
        <member name="M:Sparrow.Threading.DisposeOnce`1.Dispose">
            <summary>
            Runs the dispose action. Ensures any threads that are running it
            concurrently wait for the dispose to finish if it is in progress.
            
            If the dispose has already happened, the <see cref="!:TOperationMode"/> defines
            how Dispose will react. The two approaches differ only in error
            handling.
            
            When behavior is <see cref="T:Sparrow.Threading.ExceptionRetry"/>, we will retry the
            Dispose until it succeeds. Retry, however, happens on successive
            calls to Dispose, rather than in a single attempt.
            
            When behavior is <see cref="T:Sparrow.Threading.SingleAttempt"/> or <see cref="!:SingleAttemptWithWaitForDisposeToFinish"/>, a failure means all
            subsequent calls will fail by throwing the same exception that
            was thrown by the action.
            </summary>
        </member>
        <member name="M:Sparrow.Threading.DisposeOnceAsync`1.DisposeAsync">
            <summary>
            Runs the dispose action. Ensures any threads that are running it
            concurrently wait for the dispose to finish if it is in progress.
            
            If the dispose has already happened, the <see cref="!:TOperationMode"/> defines
            how Dispose will react. The two approaches differ only in error
            handling.
            
            When behavior is <see cref="T:Sparrow.Threading.ExceptionRetry"/>, we will retry the
            Dispose until it succeeds. Retry, however, happens on successive
            calls to Dispose, rather than in a single attempt.
            
            When behavior is <see cref="T:Sparrow.Threading.SingleAttempt"/> or <see cref="!:SingleAttemptWithWaitForDisposeToFinish"/>, a failure means all
            subsequent calls will fail by throwing the same exception that
            was thrown by the action.
            </summary>
        </member>
        <member name="T:Sparrow.Threading.MultipleUseFlag">
            <summary>
            An atomic, thread-safe, multiple use flag that can be raised and
            lowered at will; meant to be single-user. DO NOT PASS THIS AROUND.
            </summary>
            
            Example use case is one class has multiple threads that access it
            and change the behavior externally, such as "stop logging".
            
            For convincing on why you should use this class instead of rolling
            your own, see
            http://blog.alexrp.com/2014/03/30/dot-net-atomics-and-memory-model-semantics/
            and https://issues.hibernatingrhinos.com/issue/RavenDB-8260 .
            
            PERF: This is a class instead of a struct simply because we can not
            verify that it won't be copied, and we don't trust our users not to
            copy it. It is kept so that we can move all usages back at once into
            structs should this be a perf issue in the future.
        </member>
        <member name="M:Sparrow.Threading.MultipleUseFlag.#ctor(System.Boolean)">
            <summary>
            Creates a flag.
            </summary>
            <param name="raised">if it should be raised or not</param>
        </member>
        <member name="M:Sparrow.Threading.MultipleUseFlag.RaiseOrDie">
            <summary>
            Raises the flag. If already up, throws InvalidOperationException.
            </summary>
        </member>
        <member name="M:Sparrow.Threading.MultipleUseFlag.ThrowRaiseException">
            <summary>
            This is here to allow RaiseOrDie() to be inlined.
            </summary>
        </member>
        <member name="M:Sparrow.Threading.MultipleUseFlag.LowerOrDie">
            <summary>
            Lowers the flag. If already low, throws InvalidOperationException.
            </summary>
        </member>
        <member name="M:Sparrow.Threading.MultipleUseFlag.ThrowLowerException">
            <summary>
            This is here to allow LowerOrDie() to be inlined.
            </summary>
        </member>
        <member name="M:Sparrow.Threading.MultipleUseFlag.Lower">
            <summary>
            Lowers the flag
            </summary>
            <returns>If already low, false; otherwise, true</returns>
        </member>
        <member name="M:Sparrow.Threading.MultipleUseFlag.Raise">
            <summary>
            Raises the flag
            </summary>
            <returns>If already raised, false; otherwise, true</returns>
        </member>
        <member name="M:Sparrow.Threading.MultipleUseFlag.IsRaised">
            <returns>True iff the flag is raised</returns>
        </member>
        <member name="M:Sparrow.Threading.MultipleUseFlag.op_Implicit(Sparrow.Threading.MultipleUseFlag)~System.Boolean">
            <summary>
            Returns true iff the flag is raised. Same as calling IsRaised().
            </summary>
            <param name="flag">Flag to check</param>
        </member>
        <member name="T:Sparrow.Threading.SharedMultipleUseFlag">
            <summary>
            A thread-safe, multiple use flag that can be raised and lowered at
            will; meant to be shared between many users.
            </summary>
            
            Example use case is one class wants to let others know that an event
            has happened (i.e. the system is running out of memory), but does not
            want to use a callback. Then, the class can have a SharedMultipleUseFlag,
            which it passes by reference to others who want to be notified, and 
            simply raises it and lowers it as desired.
            
            For convincing on why you should use this class instead of rolling your
            own, see http://blog.alexrp.com/2014/03/30/dot-net-atomics-and-memory-model-semantics/
            and https://issues.hibernatingrhinos.com/issue/RavenDB-8260 .
            
            This is a class instead of a struct so that multiple holders may share
            a single flag, do NOT change this without revisiting call places.
        </member>
        <member name="F:Sparrow.Threading.SharedMultipleUseFlag.None">
            <summary>
            This flag is always lowered and should not be raised by anyone.
            </summary>
        </member>
        <member name="M:Sparrow.Threading.SharedMultipleUseFlag.#ctor(Sparrow.Threading.SharedMultipleUseFlag)">
            <summary>
            Copy constructor. DO NOT USE.
            </summary>
        </member>
        <member name="M:Sparrow.Threading.SharedMultipleUseFlag.#ctor">
            <summary>
            Creates a lowered flag.
            </summary>
        </member>
        <member name="M:Sparrow.Threading.SharedMultipleUseFlag.#ctor(System.Boolean)">
            <summary>
            Creates a flag.
            </summary>
            <param name="raised">if it should be raised or not</param>
        </member>
        <member name="M:Sparrow.Threading.SharedMultipleUseFlag.RaiseOrDie">
            <summary>
            Raises the flag. If already up, throws InvalidOperationException.
            </summary>
        </member>
        <member name="M:Sparrow.Threading.SharedMultipleUseFlag.LowerOrDie">
            <summary>
            Lowers the flag. If already low, throws InvalidOperationException.
            </summary>
        </member>
        <member name="M:Sparrow.Threading.SharedMultipleUseFlag.Lower">
            <summary>
            Lowers the flag
            </summary>
            <returns>If already low, false; otherwise, true</returns>
        </member>
        <member name="M:Sparrow.Threading.SharedMultipleUseFlag.Raise">
            <summary>
            Raises the flag
            </summary>
            <returns>If already raised, false; otherwise, true</returns>
        </member>
        <member name="M:Sparrow.Threading.SharedMultipleUseFlag.IsRaised">
            <returns>True iff the flag is raised</returns>
        </member>
        <member name="M:Sparrow.Threading.SharedMultipleUseFlag.op_Implicit(Sparrow.Threading.SharedMultipleUseFlag)~System.Boolean">
            <summary>
            Returns true iff the flag is raised. Same as calling IsRaised().
            </summary>
            <param name="flag">Flag to check</param>
        </member>
        <member name="T:Sparrow.Threading.SingleUseFlag">
            <summary>
            A thread-safe, single use flag that can be raised once; meant to be
            single-user. DO NOT PASS THIS AROUND.
            </summary>
            
            Example use case is a class which runs on multiple threads wants to 
            know if it has been disposed or not, or whether a particular event is
            currently happening.
            
            For convincing on why you should use this class instead of rolling your
            own, see http://blog.alexrp.com/2014/03/30/dot-net-atomics-and-memory-model-semantics/
            and https://issues.hibernatingrhinos.com/issue/RavenDB-8260 .
            
            PERF: This is a class instead of a struct simply because we can not
            verify that it won't be copied, and we don't trust our users not to
            copy it. It is kept so that we can move all usages back at once into
            structs should this be a perf issue in the future.
        </member>
        <member name="M:Sparrow.Threading.SingleUseFlag.#ctor(System.Boolean)">
            <summary>
            Creates a flag.
            </summary>
            <param name="raised">if it should be raised or not</param>
        </member>
        <member name="M:Sparrow.Threading.SingleUseFlag.RaiseOrDie">
            <summary>
            Raises the flag. If already up, throws InvalidOperationException.
            </summary>
        </member>
        <member name="M:Sparrow.Threading.SingleUseFlag.ThrowException">
            <summary>
            This is here to allow RaiseOrDie() to be inlined.
            </summary>
        </member>
        <member name="M:Sparrow.Threading.SingleUseFlag.Raise">
            <summary>
            Raises the flag
            </summary>
            <returns>If already raised, false; otherwise, true</returns>
        </member>
        <member name="M:Sparrow.Threading.SingleUseFlag.IsRaised">
            <returns>True iff the flag is raised</returns>
        </member>
        <member name="M:Sparrow.Threading.SingleUseFlag.op_Implicit(Sparrow.Threading.SingleUseFlag)~System.Boolean">
            <summary>
            Returns true iff the flag is raised. Same as calling IsRaised().
            </summary>
            <param name="flag">Flag to check</param>
        </member>
        <member name="T:Sparrow.Utils.CommandLineArgumentEscaper">
            <summary>
            A utility for escaping arguments for new processes.
            </summary>
        </member>
        <member name="M:Sparrow.Utils.CommandLineArgumentEscaper.EscapeAndConcatenate(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Undo the processing which took place to create string[] args in Main, so that the next process will
            receive the same string[] args.
            </summary>
            <remarks>
            See https://blogs.msdn.microsoft.com/twistylittlepassagesallalike/2011/04/23/everyone-quotes-command-line-arguments-the-wrong-way/
            </remarks>
            <param name="args">The arguments</param>
            <returns>A single string of escaped arguments</returns>
        </member>
        <member name="M:System.IO.StreamExtensions.Read(System.IO.Stream,System.Span{System.Byte})">
            <summary>
            https://github.com/dotnet/runtime/blob/0f829188c6c1ca35a951214f8e9c43f377953b96/src/libraries/System.Private.CoreLib/src/System/IO/Stream.cs#L814-L828
            </summary>
        </member>
        <member name="M:System.IO.StreamExtensions.ReadAsync(System.IO.Stream,System.Memory{System.Byte},System.Threading.CancellationToken)">
            <summary>
            https://github.com/dotnet/runtime/blob/0f829188c6c1ca35a951214f8e9c43f377953b96/src/libraries/System.IO.Pipelines/src/System/IO/Pipelines/StreamExtensions.netstandard.cs#L18-L43
            </summary>
        </member>
        <member name="M:System.IO.StreamExtensions.Write(System.IO.Stream,System.ReadOnlySpan{System.Byte})">
            <summary>
            https://github.com/dotnet/runtime/blob/0f829188c6c1ca35a951214f8e9c43f377953b96/src/libraries/System.Private.CoreLib/src/System/IO/Stream.cs#L847-L856
            </summary>
        </member>
        <member name="M:System.Net.WebSockets.WebSocketExtensions.ReceiveAsync(System.Net.WebSockets.WebSocket,System.Memory{System.Byte},System.Threading.CancellationToken)">
            <summary>
            https://github.com/dotnet/runtime/blob/0f829188c6c1ca35a951214f8e9c43f377953b96/src/libraries/System.Net.WebSockets/src/System/Net/WebSockets/WebSocket.cs#L36-L55
            </summary>
        </member>
    </members>
</doc>
